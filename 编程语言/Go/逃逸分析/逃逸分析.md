# 逃逸分析

> [!note|label: 逃逸分析]
>
> 在程序编译阶段根据程序代码中的数据流，对代码中哪些变量需要在栈上分配，哪些变量需要在堆上分配进行静态分析的方法。
>
> `-m 打印逃逸分析信息，-l 禁止内联优化，再添加 - m 参数，显示更多细节。`

在 Go 中，执行用户代码的 goroutine 是一种用户态线程，其调用栈内存被称为用户栈，它其实也是从堆区分配的，但是我们仍然可以将其看作和系统栈一样的内存空间，它的分配和释放是通过编译器完成的。与其相对应的是系统栈，它的分配和释放是操作系统完成的。在 GMP 模型中，一个 M 对应一个系统栈（也称为 M 的 g0 栈），M 上的多个 goroutine 会共享该系统栈。

不同平台上的 ` 系统栈 ` 最大限制不同：

```bash
$ ulimit -s
8192
```

以 x86_64 架构为例，它的系统栈大小最大可为 8Mb。我们常说的 goroutine 初始大小为 2kb，其实说的是用户栈，它的最小和最大可以在 runtime/stack.go 中找到，分别是 2KB 和 1GB。

```go
// The minimum size of stack used by Go code
_StackMin = 2048
...
var maxstacksize uintptr = 1 << 20 // enough until runtime.main sets it for real
```

## 内存逃逸的典型情况

- 指针逃逸。返回局部变量的指针，其生命周期大于栈。
- 栈空间不足。当栈空间不足时，会把对象分配到堆中，此时也会发生内存逃逸。
- 动态类型逃逸。编译期间很难确定其参数的具体类型。
- 发送指针或带有指针的值到 channel 中，在编译时，没有办法知道哪个 goroutine 会在 channel 上接收数据。所以编译器无法知道变量什么时候才会被释放。
- 在切片上存储指针或带指针的值。一个典型的例子就是 []*string，这会导致切片的内容逃逸，尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上。
- 闭包引用对象逃逸。
- 变量大小不确定。

```go
package main

func foo() {
    n := 1
    // 无法判断当前切片长度
    s := make([]int, n)
    for i := 0; i <len(s); i++ {
        s[i] = i
    }
}

func main() {
    foo()
}
```

指针传递一定比值传递效率更高吗？

传递指针可以减少底层值的复制，可以提高效率，但是如果复制的数据量小，由于指针传递会产生逃逸，则可能使用堆，也可能增加 GC 的负担。

## 总结

- 堆上动态分配内存比栈上静态分配内存，开销大很多。
- 变量分配在栈上需要能在编译期确定它的作用域，否则会分配到堆上。
- `go build -gcflags '-m'` 命令观察变量逃逸情况。
- 不要盲目使用变量的指针作为函数参数，虽然它会减少复制操作，但其实当参数为变量自身的时候，复制是在栈上完成的操作，开销远比变量逃逸后动态地在堆上分配内存少的多。
- 逃逸分析在编译阶段完成。