# I/O 分类

转自：https://github.com/youthlql/JavaYouth

## 阻塞与非阻塞 I/O

## 同步与异步 I/O

## 直接与非直接 I/O

1. 磁盘 I/O 是非常慢的，所以 Linux 内核通过减少磁盘 I/O 次数来减少 I/O 时间，在系统调用后，会把用户数据拷贝到内核中缓存起来，这个内核缓存空间也就是页缓存（PageCache），只有当缓存满足某些条件的时候，才发起磁盘 I/O 的请求。

2. 根据是否 ` 用操作系统的页缓存 `，可以把文件 I/O 分为直接 I/O 与非直接 I/O：
   - 直接 I/O：不会发生内核缓存和用户程序之间数据复制，跳过操作系统的页缓存，直接经过文件系统访问磁盘。
   - 非直接 I/O：读操作时，数据从内核缓存中拷贝给用户程序；写操作时，数据从用户程序拷贝给内核缓存，再由内核决定什么时候写入数据到磁盘。

3. 想要实现直接 I/O，需要你在系统调用中，指定 O_DIRECT 标志。如果没有设置过，默认的是非直接 I/O。

在进行写操作的时候以下几种场景会触发内核缓存的数据写入磁盘：

> [!note|label:《深入 linux 内核架构》]
> 
> 1. 可能因不同原因、在不同的时机触发不同的刷出数据的机制。
> - 周期性的内核线程，将扫描脏页的链表，并根据页变脏的时间，来选择一些页写回。如果系统不是太忙于写操作，那么在脏页的数目，以及刷出页所需的硬盘访问操作对系统造成的负荷之间，有一个可接受的比例。
> - 如果系统中的脏页过多（例如，一个大型的写操作可能造成这种情况），内核将触发进一步的机制对脏页与后备存储器进行同步，直至脏页的数目降低到一个可接受的程度。而 “脏页过多” 和 “可接受的程度” 到底意味着什么，此时尚是一个不确定的问题，将在下文讨论。
> - 内核的各个组件可能要求数据必须在特定事件发生时同步，例如在重新装载文件系统时。
> - 前两种机制由内核线程 pdflush 实现，该线程执行同步代码，而第三种机制可能由内核中的多处代码触发。
>
> 2. 可以从用户空间通过各种系统调用来启用内核同步机制，以确保内存和块设备之间（完全或部分）的数据完整性。有如下 3 个基本选项可用。
> - 使用 sync 系统调用刷出整个缓存内容。在某些情况下，这可能非常耗时。
> - 各个文件的内容（以及相关 inode 的元数据）可以被传输到底层的块设备。内核为此提供了 fsync 和 fdatasync 系统调用。尽管 sync 通常与上文提到的系统工具 sync 联合使用，但 fsync 和 fdatasync 则专用于特定的应用程序，因为刷出的文件是通过特定于进程的文件描述符（在第 8 章介绍）来选择的。因而，没有一个通用的用户空间工具可以回写特定的文件。
> - msync 用于同步内存映射。

> [!note|label: 脏页]
> Linux 内核中的概念，因为硬盘的读写速度远赶不上内存的速度，系统就把读写比较频繁的数据事先放到内存中，以提高读写速度，这就叫高速缓存，Linux 是以页作为高速缓存的单位，当进程修改了高速缓存里的数据时，该页就被内核标记为脏页，内核将会在合适的时间把脏页的数据写到磁盘中去，以保持高速缓存中的数据和磁盘中的数据是一致的。

通过对上面的解读，我们用通俗的语言翻译以下：
- 周期性的扫描脏页，如果发现脏页存在的时间过了某一时间时，也会把该脏页的数据刷到磁盘上。
- 当发现脏页太多的时候，内核会把一定数量的脏页数据写到磁盘上。
- 用户主动调用 `sync`、`fsync`、`fdatasync`，内核缓存会刷到磁盘上。

## 缓冲与非缓冲 I/O

1. 文件操作的标准库是可以实现数据的缓存，那么根据 ` 是否利用标准库缓冲 `，可以把文件 I/O 分为缓冲 I/O 和非缓冲 I/O：
   - 缓冲 I/O，利用的是标准库的缓存实现文件的加速访问，而标准库再通过系统调用访问文件。
   - 非缓冲 I/O，直接通过系统调用访问文件，不经过标准库缓存。

2. 这里所说的「缓冲」特指标准库内部实现的缓冲。比方说，很多程序遇到换行时才真正输出，而换行前的内容，其实就是被标准库暂时缓存了起来，这样做的目的是，减少系统调用的次数。
3. 非缓冲 I/O，因为没有标准库提供的缓冲，只能用操作系统的缓存区，会造成很多次的系统调用，降低效率。
4. 缓存 I/O 也叫标准 I/O，符合 ANSI C 的标准 IO 处理，不依赖系统内核，所以移植性强，我们使用标准 IO 操作很多时候是为了减少对 read() 和 write() 的系统调用次数，带缓存 IO 其实就是在用户层再建立一个缓存区，这个缓存区的分配和优化长度等细节都是标准 IO 库代你处理好了，不用去操心。

> [!note|label:《深入 linux 内核架构》]
> 
> 标准 I/O 库提供缓冲的目的是尽可能减少使用 read 和 write 调用的次数。它也对每个 I/O 流自动地进行缓冲管理，从而避免了应用程序需要考虑这一点所带来的麻烦。遗憾的是，标准 I/O 库最令人迷惑的也是它的缓冲。
> 
> 标准 I/O 提供了以下 3 种类型的缓冲：
> 1. `全缓冲`。在这种情况下，在`填满标准 I/O 缓冲区`后才进行实际 I/O 操作。对于驻留在磁盘上的文件通常是由标准 I/O 库实施全缓冲的。在一个流上执行第一次 I/O 操作时，相关标准 I/O 函数通常调用 malloc 获得需使用的缓冲区。术语冲洗（fush）说明标准 UO 缓冲区的写操作。缓冲区可由标准 I/O 例程自动地冲洗（例如，当填满一个缓冲区时），或者可以调用函数 fflush 冲洗一个流。值得注意的是，在 UNTX 环境中，fush 有两种意思。在标准 I/O 库方面，flush（冲洗）意味着将缓冲区中的内容写到磁盘上（该缓冲区可能只是部分填满的）。在终端驱动程序方面（例如，在第 18 章中所述的 tcflush 函数），flush（刷清）表示丢弃已存储在缓冲区中的数据。
> 2. `行缓冲`。在这种情况下，当在输入和输出中遇到换行符时，标准 I/O 库执行 I/O 操作。这允许我们一次输出一个字符（用标准 I/O 函数 fputc），但只有在写了一行之后才进行实际 I/O 操作。当流涉及一个终端时（如标准输入和标准输出），通常使用行缓冲。对于行缓冲有两个限制。第一，因为标准 I/O 库用来收集每一行的缓冲区的长度是固定的。所以只要填满了缓冲区，那么即使还没有写一个换行符，也进行 I/O 操作。第二，任何时候只要通过标准 I/O 库要求从（a）一个不带缓冲的流，或者（b）一个行缓冲的流（它从内核请求需要数据）得到输入数据，那么就会冲洗所有行缓冲输出流。在（b）中带了一个在括号中的说明，其理由是，所需的数据可能已在该缓冲区中，它并不要求一定从内核读数据。很明显，从一个不带缓冲的流中输入（即（a）项）需要从内核获得数据。
> 3. `不带缓冲`。标准 I/O 库不对字符进行缓冲存储，例如，若用标准 I/O 函数 fputs 写 15 个字符到不带缓冲的流中，我们就期望这 15 个字符能立即输出，很可能使用 3.8 节的 write 函数将这些字符写到相关联的打开文件中。
